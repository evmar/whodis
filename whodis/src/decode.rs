pub fn sample() -> Vec<iced_x86::Instruction> {
    let paint: [u8; 175] = [
        0x83, 0xec, 0x50, 0x56, 0x8b, 0xf1, 0x8b, 0x46, 0x04, 0x8b, 0x40, 0x04, 0x6a, 0x00, 0x8d,
        0x4c, 0x24, 0x08, 0x51, 0x50, 0xff, 0x15, 0x64, 0x52, 0x44, 0x00, 0x85, 0xc0, 0x74, 0x57,
        0x8b, 0x56, 0x04, 0x8b, 0x42, 0x04, 0x57, 0x8d, 0x4c, 0x24, 0x18, 0x51, 0x50, 0xff, 0x15,
        0x68, 0x52, 0x44, 0x00, 0x8b, 0x15, 0x68, 0xbc, 0x45, 0x00, 0x8b, 0x4c, 0x24, 0x0c, 0x8b,
        0x7c, 0x24, 0x10, 0x52, 0x8b, 0x54, 0x24, 0x18, 0x2b, 0xd1, 0x52, 0x8b, 0x54, 0x24, 0x10,
        0x2b, 0xfa, 0x57, 0x51, 0x52, 0x50, 0x8d, 0x4e, 0x28, 0xe8, 0x77, 0x3e, 0xff, 0xff, 0x8b,
        0x4e, 0x04, 0x8b, 0x51, 0x04, 0x8d, 0x44, 0x24, 0x18, 0x50, 0x52, 0xff, 0x15, 0x08, 0x52,
        0x44, 0x00, 0x5f, 0x32, 0xc0, 0x5e, 0x83, 0xc4, 0x50, 0xc2, 0x04, 0x00, 0x32, 0xc0, 0x5e,
        0x83, 0xc4, 0x50, 0xc2, 0x04, 0x00, 0x90, 0x90, 0x56, 0x57, 0x8b, 0x7c, 0x24, 0x10, 0x57,
        0x68, 0x9c, 0xf7, 0x44, 0x00, 0x8b, 0xf1, 0xe8, 0x5d, 0x70, 0x02, 0x00, 0x8b, 0x44, 0x24,
        0x14, 0x83, 0xc4, 0x08, 0x57, 0x50, 0x8b, 0xce, 0xe8, 0xbd, 0x65, 0xff, 0xff, 0x5f, 0x5e,
        0xc2, 0x08, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    ];
    let eip = 0x40d580u32;

    let decoder =
        iced_x86::Decoder::with_ip(32, &paint, eip as u64, iced_x86::DecoderOptions::NONE);
    decoder.into_iter().collect()
}

pub struct Block {
    pub instrs: std::ops::Range<usize>,
}

pub fn blocks(instrs: &[iced_x86::Instruction]) -> Vec<Block> {
    let mut blocks = Vec::new();
    let mut start = 0;
    for (i, instr) in instrs.iter().enumerate() {
        if instr.flow_control() != iced_x86::FlowControl::Next {
            blocks.push(Block {
                instrs: start..i + 1,
            });
            start = i + 1;
        }
    }
    if start < instrs.len() {
        blocks.push(Block {
            instrs: start..instrs.len(),
        });
    }
    blocks
}
